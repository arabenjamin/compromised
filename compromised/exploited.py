#!usr/bin/python
# -*- coding: utf-8 -*-
from hashlib import sha1
import os


def get_line_length(file_path):
    """ Get the length of the each line """
    with open(file_path, 'rb+') as f:
        return len(f.readline())

def isPwned(file_object, hash_hex, line_length, line_index, index_range):

    """ Recursively find hash in file pwned-passwords-sha1-ordered-by-hash-v5.txt 


            To move to any particular line, we need to create and index of all the lines
            in the file. To do so, take the filesize and divide it by the length
            of the firstline line to get the total amount of hashes to be compared in this file.

            This makes an assumption that comes with gotchas.

            Currently, based on the input file being working with, 
            the length of the line in the file, multiplied by my current index
            will return roughly the byte offset of the begining of the line to be moved to 
            in odrer to compare that line with our hash. 
            
             

           

            Assuming all lines are of the same length.. they're not..        

        example:
            hash_hex = sha1(st('sercret_password_thats_probably_pwned_by_now')).hexdigest().upper()
            FILESIZE = os.path.getsize(FILENAME)
            LINE_LENGTH = get_line_length(FILENAME) # gets the line length of the first line ( can't really be trusted )
            # rough total hashes in the file ... again assuming
            MAXLINES = FILESIZE / LINE_LENGTH
            # the range of indexes to work with
            index_range = (0, MAXLINES)
            # get the middle index
            line_index = MAXLINES / 2  
            with open(FILENAME,'rb') as f:
                if isPwned(file_object, hash_hex, line_length, line_index, index_range):
                    print "This be pwned"
                else:
                    print "This be safe... for now"
             
        parameter: 
            file_object (obj):  the open file object we're working on is specificly
                                looking for pwned-passwords-sha1-ordered-by-hash-v5.txt
                                found at https://haveibeenpwned.com/Passwords
                                caution: past versions of this file may not work as expected

        parameters:
            hash_hex (str): the hexdigest of the sha1 hash we're looking for in uppercase
        parameter:
            line_length (int): the length of each line in the file ... hopefully 
        paramter: 
            line_index (int): the index of the line we want to look at
                              To get to the begining of any line multiply the line index 
                              by line length ... unless that doesn't work
        parameter: 
            index_range (tuple): the min and max of the range of lines we're working on

        returns:
            results (Boolean): True if isPwned, else False
    """
    
    #get the bytes for the line index
    pos = int(line_index)*line_length
    # goto that location
    file_object.seek(pos ,0)
    # read the line
    line = file_object.readline()

    """ handel the gotcha """
    if len(line) != line_length:
        """ TODO: FIXME: We landed in the middle of a line ...
             
            The last byte offset was wrong because while each
            line is a 40 character hash followed by a ':n 
            followed by an carrage return and a new line character,
            where n can be any length int. 
            Could be a 2, could be 500, the later would make our assumption 
            that the line length was fixed incorrect  

        """
        # adjust the position to the begining of the line we want to look at
        adj_pos = pos - (line_length - len(line)) 
        # goto that position
        file_object.seek(adj_pos ,0)
        # now read the line
        line = file_object.readline()

    if hash_hex == line.split(':')[0]:
        # oh snap! We've been pwned, burn this password.
        return True
        
    if index_range[0] == index_range[1] or (index_range[1] - index_range[0]) == 1:
        # Pheew, we ain't find nothing!
        return False

    # decide the next index and index range
    if hash_hex > line.split(':')[0]:
        # Goto next line_index up
        # Our next index should be greter than the current index
        next_index = line_index + (index_range[1]-line_index)/2
        next_range = (line_index, index_range[1])
        return isPwned(file_object, hash_hex, line_length, int(next_index), next_range)

   
    """ There can be no other context other than our hash is less than the line we're looking at """

    # Goto next line_index down 
    next_index = line_index - (line_index - index_range[0])/2
    next_range = (index_range[0], line_index)
    return isPwned(file_object, hash_hex, line_length, int(next_index), next_range)



